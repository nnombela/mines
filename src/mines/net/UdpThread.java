package mines.net;

/**
 * UDPServer class
 * <p/>
 * This class is used to ...
 *
 * @author <a href="mailto:nnombela@gmail.com">Nicolas Nombela</a>
 * @since 09-jul-2006
 */

import mines.model.Player;
import java.net.*;
import java.io.*;
import java.nio.channels.DatagramChannel;
import java.nio.ByteBuffer;

public abstract class UdpThread extends Thread {
    protected static final int SERVER_DEFAULT_PORT = 1234;
    protected static final int CLIENT_DEFAULT_PORT = 1235;
    protected static final int BUFFER_CAPACITY = 8192;

    protected DatagramChannel channel;
    protected MixedBuffer buffer;
    private boolean halt = false;
    

    public UdpThread(int port, int range) throws IOException {
        this.buffer = new MixedBuffer(BUFFER_CAPACITY);
        this.channel = DatagramChannel.open();
        bindSocket(port, range);
    }


    private void bindSocket(int port, int range) throws SocketException {
        try  {
            channel.socket().bind(new InetSocketAddress(port));
            System.out.println("socket bound to port: " + port);
        } catch (BindException bindException) {
            System.err.println("can not bound socket to port: " + port + " trying to bound to " + (port +1));
            if (--range > 0) {
                bindSocket(port + 1, range);
            } else {
                bindException.printStackTrace();
            }
        }
    }

    public DatagramChannel getChannel() {
        return channel;
    }

    public void halt( ) {
        this.halt = true;
        channel.socket().close();
        System.out.println("socket closed");
    }

    public void run() {
        if (channel.socket().isBound()) {
            while (halt == false) {
                try {
                    process(receive());
                } catch (Exception e) {
                    e.printStackTrace();
                }
                Thread.yield();
            }
        }
    }

    protected InetSocketAddress receive() throws IOException {
        ByteBuffer rcvBuffer = buffer.receiver();
        rcvBuffer.clear();
        SocketAddress address = channel.receive(rcvBuffer);
        rcvBuffer.flip();
        return (InetSocketAddress)address;
    }

    protected void send(InetSocketAddress address)  {
        try {
            ByteBuffer sndBuffer = buffer.sender();
            sndBuffer.flip();
            channel.send(sndBuffer, address);
            sndBuffer.clear();
        } catch (IOException e) {
            e.printStackTrace();  //autogenerated
        }
    }

    protected void passAcross(InetSocketAddress address) {
        try {
            ByteBuffer rcvBuffer = buffer.receiver();
            rcvBuffer.rewind();
            channel.send(rcvBuffer, address);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    protected abstract void process(InetSocketAddress address) ;
}